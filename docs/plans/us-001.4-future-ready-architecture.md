# US-001.4 Future-Ready Architecture Implementation Plan

**User Story:** US-001.4 - Establish future-ready architecture  
**Version:** 1.0  
**Date:** September 3, 2025  
**Scope:** Architecture design for plugin systems and multi-crate modules  
**Phase:** Phase 1 (Foundation)  

## Executive Summary

This plan details the implementation of US-001.4: establishing a future-ready architecture that supports plugin systems and multi-crate modules without requiring major refactoring. The scope focuses on creating proper abstractions, interfaces, and architectural patterns that will enable seamless integration of future modules (audio, AI, blocks, resources) while maintaining clean separation of concerns.

## User Story Details

**ID:** US-001.4  
**Description:** As a developer, I want the architecture to support future plugin systems and multi-crate modules so that the foundation can scale without major refactoring

**Acceptance Criteria:**
- Code structure that supports future event bus implementation
- Module boundaries designed for independent crate development  
- Interface definitions that can accommodate future audio, AI, and block modules
- Configuration system ready for multi-module setup
- Documentation of architectural decisions and extension points

## Current State Analysis

Based on the existing foundation implementation:
- ✅ Basic DDD architecture with Domain, Application, Infrastructure layers
- ✅ Hexagonal architecture with ports/adapters pattern
- ✅ Database service with clean abstractions
- ⚠️ **Gap:** No event bus foundation or module registry
- ⚠️ **Gap:** No plugin interface definitions
- ⚠️ **Gap:** No multi-module configuration system
- ⚠️ **Gap:** Limited documentation of extension points

## Architecture Design

### 1. Event Bus Foundation

Even though the event bus implementation is deferred to Phase 3, we need to establish the foundation patterns:

```rust
// domain/events.rs
pub trait DomainEvent: Send + Sync + Clone {
    fn event_type(&self) -> &'static str;
    fn timestamp(&self) -> chrono::DateTime<chrono::Utc>;
    fn source_module(&self) -> &'static str;
}

// application/ports/event_bus.rs  
#[async_trait]
pub trait EventBus: Send + Sync {
    async fn publish<T: DomainEvent>(&self, event: T) -> Result<(), EventBusError>;
    async fn subscribe<T: DomainEvent>(&self, handler: Box<dyn EventHandler<T>>) -> Result<(), EventBusError>;
}

// application/ports/event_handler.rs
#[async_trait]
pub trait EventHandler<T: DomainEvent>: Send + Sync {
    async fn handle(&self, event: T) -> Result<(), EventHandlerError>;
}
```

### 2. Module Registry System

Establish patterns for future module registration:

```rust
// application/ports/module_registry.rs
pub trait ModuleRegistry: Send + Sync {
    fn register_module(&mut self, module: Box<dyn Module>) -> Result<(), ModuleError>;
    fn get_module(&self, name: &str) -> Option<&dyn Module>;
    fn list_modules(&self) -> Vec<&dyn Module>;
    fn is_module_loaded(&self, name: &str) -> bool;
}

// application/ports/module.rs
#[async_trait]
pub trait Module: Send + Sync {
    fn name(&self) -> &'static str;
    fn version(&self) -> &'static str;
    fn dependencies(&self) -> Vec<&'static str>;
    async fn initialize(&self, context: &ModuleContext) -> Result<(), ModuleError>;
    async fn shutdown(&self) -> Result<(), ModuleError>;
}
```

### 3. Plugin Interface Foundation

Define interfaces that future plugins can implement using a capability-based system with runtime loading:

```rust
// application/ports/plugin.rs
#[async_trait]
pub trait Plugin: Send + Sync {
    fn id(&self) -> &'static str;
    fn name(&self) -> &'static str;
    fn version(&self) -> &'static str;
    fn capabilities(&self) -> Vec<PluginCapability>;
    async fn load(&self, context: &PluginContext) -> Result<(), PluginError>;
    async fn unload(&self) -> Result<(), PluginError>;
    
    // Runtime loading support
    fn can_hot_reload(&self) -> bool { true }
    async fn reload(&self, context: &PluginContext) -> Result<(), PluginError>;
}

// Plugin capabilities - what the framework needs to know about plugin functionality
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum PluginCapability {
    // Block system - core to IdeaNet's content model
    BlockRenderer { block_type: String },
    BlockEditor { block_type: String },
    
    // Event system - for loose coupling (plugins register their own handlers during load)
    EventListener { event_types: Vec<String> },
    EventPublisher { event_types: Vec<String> },
    
    // System capabilities - plugins can provide system-level functionality
    // Note: Actual audio recording implementation is out of scope for Phase 1
    // These are examples of how plugins could declare system capabilities
    RecordSystemAudio,
    RecordMicrophone,
}

// Plugin loading support for runtime discovery
#[derive(Debug)]
pub struct PluginMetadata {
    pub path: PathBuf,
    pub last_modified: SystemTime,
    pub loaded: bool,
    pub load_order: u32,
}

// Plugin context for initialization - plugins register themselves during load
pub struct PluginContext {
    pub config: HashMap<String, serde_json::Value>,
    pub event_bus: Arc<dyn EventBus>,
    pub service_locator: Arc<dyn ServiceLocator>,
    pub app_version: String,
    // Plugins can register UI components, resource handlers, etc. during load
    pub ui_registry: Arc<dyn UiRegistry>,
    pub resource_registry: Arc<dyn ResourceRegistry>,
}

// UI and resource registration done during plugin load, not as capabilities
#[async_trait]
pub trait UiRegistry: Send + Sync {
    async fn register_toolbar_item(&self, plugin_id: &str, item: ToolbarItem) -> Result<(), UiError>;
    async fn register_sidebar_panel(&self, plugin_id: &str, panel: SidebarPanel) -> Result<(), UiError>;
    async fn register_context_menu(&self, plugin_id: &str, menu: ContextMenu) -> Result<(), UiError>;
    async fn unregister_ui_items(&self, plugin_id: &str) -> Result<(), UiError>;
}

#[async_trait]
pub trait ResourceRegistry: Send + Sync {
    async fn register_importer(&self, plugin_id: &str, mime_types: Vec<String>, handler: ResourceImporter) -> Result<(), ResourceError>;
    async fn register_previewer(&self, plugin_id: &str, mime_types: Vec<String>, handler: ResourcePreviewer) -> Result<(), ResourceError>;
    async fn unregister_handlers(&self, plugin_id: &str) -> Result<(), ResourceError>;
}
```
```

### 4. Configuration System Architecture

Design configuration to support multiple modules and capability-based plugins:

```rust
// application/config/mod.rs
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AppConfig {
    pub database: DatabaseConfig,
    pub modules: ModulesConfig,
    pub plugins: PluginsConfig,
    pub event_bus: EventBusConfig,
    pub capabilities: CapabilitiesConfig,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ModulesConfig {
    pub enabled_modules: Vec<String>,
    pub module_paths: HashMap<String, PathBuf>,
    pub module_configs: HashMap<String, serde_json::Value>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PluginsConfig {
    pub plugin_directories: Vec<PathBuf>,
    pub enabled_plugins: Vec<String>,
    pub plugin_configs: HashMap<String, serde_json::Value>,
    pub capability_mappings: HashMap<String, Vec<String>>, // capability -> plugin_ids
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CapabilitiesConfig {
    pub required_capabilities: Vec<String>,
    pub optional_capabilities: Vec<String>,
    pub capability_priorities: HashMap<String, i32>, // for multiple providers
}
```

### 5. Capability Registry Pattern

Implement capability-based service discovery for plugins with runtime loading support:

```rust
// application/services/capability_registry.rs
#[async_trait]
pub trait CapabilityRegistry: Send + Sync {
    fn register_plugin(&mut self, plugin: Arc<dyn Plugin>) -> Result<(), CapabilityError>;
    fn unregister_plugin(&mut self, plugin_id: &str) -> Result<(), CapabilityError>;
    fn get_plugins_with_capability(&self, capability: &PluginCapability) -> Vec<Arc<dyn Plugin>>;
    fn get_plugin_capabilities(&self, plugin_id: &str) -> Option<Vec<PluginCapability>>;
    fn has_capability(&self, capability: &PluginCapability) -> bool;
    fn get_best_plugin_for_capability(&self, capability: &PluginCapability) -> Option<Arc<dyn Plugin>>;
    
    // Runtime loading support
    async fn discover_plugins(&mut self, directories: &[PathBuf]) -> Result<Vec<PluginMetadata>, CapabilityError>;
    async fn load_plugin(&mut self, path: &Path) -> Result<Arc<dyn Plugin>, CapabilityError>;
    async fn unload_plugin(&mut self, plugin_id: &str) -> Result<(), CapabilityError>;
    async fn reload_plugin(&mut self, plugin_id: &str) -> Result<(), CapabilityError>;
    fn list_loaded_plugins(&self) -> Vec<(String, PluginMetadata)>;
}

// Plugin loader trait for dynamic loading
#[async_trait]
pub trait PluginLoader: Send + Sync {
    async fn can_load(&self, path: &Path) -> bool;
    async fn load_plugin(&self, path: &Path) -> Result<Box<dyn Plugin>, PluginError>;
    fn supported_extensions(&self) -> Vec<&'static str>;
}

// application/context/mod.rs
pub struct ApplicationContext {
    pub config: AppConfig,
    pub service_locator: Arc<dyn ServiceLocator>,
    pub event_bus: Arc<dyn EventBus>,
    pub module_registry: Arc<dyn ModuleRegistry>,
    pub capability_registry: Arc<dyn CapabilityRegistry>,
    pub plugin_loader: Arc<dyn PluginLoader>,
}
```

## Implementation Tasks

### Task 1: Event Bus Foundation (2-3 hours)

**Scope:** Create trait definitions and basic patterns for future event bus

**Files to create/modify:**
- `src-tauri/src/domain/events.rs` - Event trait definitions
- `src-tauri/src/application/ports/event_bus.rs` - Event bus port
- `src-tauri/src/application/ports/event_handler.rs` - Event handler trait
- `src-tauri/src/domain/errors.rs` - Add event-related errors

**Acceptance Criteria:**
- Event traits compile without errors
- Event bus port defines clear interface for future implementation
- Error types cover event bus scenarios
- Basic event types defined for database operations

### Task 2: Plugin System with Registration-Based Architecture (3-4 hours)

**Scope:** Establish capability registry and plugin interfaces with capability-based system and registration-based UI/resource handling

**Files to create/modify:**
- `src-tauri/src/application/ports/plugin.rs` - Plugin trait with capability system and runtime loading
- `src-tauri/src/application/services/capability_registry.rs` - Capability registry with runtime loading support
- `src-tauri/src/application/services/plugin_loader.rs` - Plugin loading and discovery system
- `src-tauri/src/application/ports/ui_registry.rs` - UI component registration during plugin load
- `src-tauri/src/application/ports/resource_registry.rs` - Resource handler registration during plugin load
- `src-tauri/src/application/ports/module_registry.rs` - Module registry trait
- `src-tauri/src/application/ports/module.rs` - Module trait definition
- `src-tauri/src/domain/errors.rs` - Add module/plugin/capability errors

**Acceptance Criteria:**
- Plugin interface uses capability-based system (blocks, events, and system capabilities)
- Plugins register UI components and resource handlers during load/unload lifecycle
- Capability registry supports runtime plugin loading, unloading, and reloading
- UI and resource handling done through registration, not capabilities
- Plugin discovery system can scan directories for new plugins
- Plugin loader supports dynamic loading from filesystem
- Clear separation between modules and plugins
- Error handling for module lifecycle and capability operations
- Plugins can be hot-reloaded during development
- System capabilities (like RecordSystemAudio, RecordMicrophone) defined for future use
- Note: Audio recording implementation is out of scope - only infrastructure setup

### Task 3: Configuration System Enhancement (2-3 hours)

**Scope:** Extend configuration to support multi-module setup and capability management

**Files to create/modify:**
- `src-tauri/src/application/config/mod.rs` - Enhanced configuration structures with capability config
- `src-tauri/src/application/config/loader.rs` - Configuration loading logic
- `src-tauri/src/application/config/validation.rs` - Configuration validation

**Acceptance Criteria:**
- Configuration supports module-specific settings
- Plugin configuration management with capability mappings
- Capability priority configuration for multiple providers
- Environment-based configuration overrides
- Configuration validation and error reporting

### Task 4: Service Locator and Registration Systems (3-4 hours)

**Scope:** Implement service discovery pattern and registration-based plugin management with runtime loading

**Files to create/modify:**
- `src-tauri/src/application/services/service_locator.rs` - Service locator implementation
- `src-tauri/src/application/services/capability_registry.rs` - Capability registry with runtime support
- `src-tauri/src/application/services/plugin_loader.rs` - Runtime plugin loading implementation
- `src-tauri/src/application/services/ui_registry.rs` - UI component registration system
- `src-tauri/src/application/services/resource_registry.rs` - Resource handler registration system
- `src-tauri/src/application/context/mod.rs` - Application context with all registries
- `src-tauri/src/application/services/mod.rs` - Update service module

**Acceptance Criteria:**
- Type-safe service registration and retrieval
- Capability-based plugin discovery and management
- Registration-based UI and resource handling during plugin lifecycle
- Runtime plugin loading, unloading, and reloading support
- Plugin discovery from filesystem directories
- Thread-safe service and registry access
- Integration with existing database service
- Clear patterns for future service registration
- Plugin capability querying for blocks, events, and system capabilities
- Hot-reload support for development workflow

### Task 5: Architecture Documentation (1-2 hours)

**Scope:** Document architectural decisions and extension points with capability approach and registration-based systems

**Files to create:**
- `docs/architecture/plugin-system.md` - Capability-based plugin architecture
- `docs/architecture/registration-based-integration.md` - How plugins register UI and resources during lifecycle
- `docs/architecture/runtime-plugin-loading.md` - Runtime loading and hot-reload documentation
- `docs/architecture/module-system.md` - Module architecture  
- `docs/architecture/event-bus.md` - Event bus design and patterns
- `docs/architecture/service-locator.md` - Service discovery documentation
- `docs/architecture/extension-points.md` - How to extend the system with capabilities

**Acceptance Criteria:**
- Clear documentation of capability-based plugin patterns
- Registration-based UI and resource handling documentation
- Runtime loading and plugin discovery documentation
- Examples of plugin capability declarations (blocks, events, and system capabilities)
- Extension point documentation with registration examples
- Decision rationale for registration-based approach over capability declarations
- Code samples showing how plugins register during load/unload
- Hot-reload development workflow documentation
- Guidelines for system capability plugins (audio/microphone recording examples)
- Clear note that audio recording implementation is out of scope for Phase 1

### Task 6: Integration and Testing (2-3 hours)

**Scope:** Integrate new architecture components with existing foundation and test registration-based system with runtime loading

**Files to modify:**
- `src-tauri/src/main.rs` - Initialize new architectural components including all registries
- `src-tauri/src/application/services/database.rs` - Integrate with service locator
- `src-tauri/src/commands/database.rs` - Update to use new patterns
- `src-tauri/src/commands/plugin.rs` - Add basic plugin management commands (load, unload, list)

**Acceptance Criteria:**
- Application starts successfully with new architecture
- Database service works through service locator
- Capability registry initializes and functions correctly for all capability types
- UI and resource registries function correctly
- Plugin loader can discover and load plugins from directories
- Runtime plugin loading/unloading works correctly with proper cleanup
- Registration-based UI and resource handling works during plugin lifecycle
- Configuration system loads and validates capability settings
- No breaking changes to existing functionality
- Basic capability querying works for blocks, events, and system capabilities
- Plugin hot-reload functionality works during development with proper registration cleanup
- Note: No actual audio recording implementation - only infrastructure testing

## Success Criteria

### Functional Requirements
- [ ] Event bus traits compile and provide clear interface contracts
- [ ] Module registry supports future independent crate loading
- [ ] Plugin interface uses capability-based system (blocks, events, and system capabilities)
- [ ] Capability registry enables querying plugins by their declared capabilities
- [ ] Registration systems allow plugins to register UI and resource handlers during lifecycle
- [ ] Runtime plugin loading, unloading, and reloading works correctly
- [ ] Plugin discovery can scan directories and detect new plugins
- [ ] Configuration system handles multi-module scenarios and capability mappings
- [ ] Service locator enables clean dependency injection
- [ ] System capabilities (RecordSystemAudio, RecordMicrophone) defined but not implemented

### Architectural Requirements
- [ ] Clean separation between framework and implementation
- [ ] Future modules can be developed independently
- [ ] Plugin architecture supports runtime discovery with registration-based integration
- [ ] Hot-reload support for plugin development workflow
- [ ] Event system supports loose coupling between modules
- [ ] Configuration supports environment-specific overrides and capability priorities
- [ ] Plugins register their integrations during load/unload rather than declaring capabilities
- [ ] Audio/AI functionality handled by plugins using external crates and event communication

### Documentation Requirements
- [ ] Architectural decisions documented with rationale for registration-based approach
- [ ] Runtime loading and hot-reload workflow documented
- [ ] Extension points clearly defined with registration examples
- [ ] Future module integration patterns documented
- [ ] Plugin development guidelines established with registration-based system usage
- [ ] Guidelines for system capability plugins (audio recording examples)
- [ ] Clear documentation that audio recording implementation is out of scope for Phase 1

### Integration Requirements
- [ ] New architecture integrates seamlessly with existing foundation
- [ ] No performance degradation from architectural additions
- [ ] Database service continues to function correctly
- [ ] Tauri commands work with new service patterns
- [ ] Capability registry performs efficiently for plugin queries
- [ ] Plugin capability resolution works correctly
- [ ] Runtime plugin loading doesn't impact application stability
- [ ] Hot-reload functionality works without memory leaks

## Future Module Integration Preview

### Audio Module Integration Pattern
```rust
// Future audio module would implement:
impl Module for AudioModule {
    fn name(&self) -> &'static str { "audio" }
    async fn initialize(&self, context: &ModuleContext) -> Result<(), ModuleError> {
        // Register audio services with service locator
        // Subscribe to relevant events
        // Initialize audio recording capabilities using external audio crates
    }
}

// Audio plugins declare system capabilities and register UI during load:
impl Plugin for AudioRecorderPlugin {
    fn capabilities(&self) -> Vec<PluginCapability> {
        vec![
            // System capabilities - what the plugin can do
            PluginCapability::RecordSystemAudio,
            PluginCapability::RecordMicrophone,
            // Event capabilities for communication
            PluginCapability::EventPublisher { 
                event_types: vec!["audio.recorded".to_string(), "audio.transcribed".to_string()] 
            },
            PluginCapability::EventListener { 
                event_types: vec!["ui.record_button_clicked".to_string()] 
            },
        ]
    }
    
    async fn load(&self, context: &PluginContext) -> Result<(), PluginError> {
        // Note: Actual audio recording implementation is out of scope for Phase 1
        // This is just an example of how a future plugin would work
        // Plugin would use external audio crates (cpal, symphonia, whisper-rs)
        // self.setup_audio_recording().await?;
        
        // Register UI components during load
        context.ui_registry.register_toolbar_item(
            self.id(), 
            ToolbarItem::new("record", "Record Audio", RecordIcon)
        ).await?;
        
        // Listen for events instead of declaring UI capabilities
        Ok(())
    }
    
    async fn unload(&self) -> Result<(), PluginError> {
        // Cleanup is automatic via plugin_id - no need to track what was registered
        Ok(())
    }
}
```

### AI Module Integration Pattern
```rust
// Future AI module would implement:
impl Module for AiModule {
    fn name(&self) -> &'static str { "ai" }
    async fn initialize(&self, context: &ModuleContext) -> Result<(), ModuleError> {
        // Register AI services with service locator
        // Subscribe to content events for analysis
        // Initialize AI provider connections using external AI crates
    }
}

// AI plugins register during load, communicate via events:
impl Plugin for ContentAnalyzerPlugin {
    fn capabilities(&self) -> Vec<PluginCapability> {
        vec![
            // Only event capabilities - everything else registered in load()
            PluginCapability::EventListener { 
                event_types: vec!["content.created".to_string(), "content.updated".to_string()] 
            },
            PluginCapability::EventPublisher { 
                event_types: vec!["ai.analysis_complete".to_string()] 
            },
        ]
    }
    
    async fn load(&self, context: &PluginContext) -> Result<(), PluginError> {
        // Plugin uses external AI crates (async-openai, anthropic, reqwest)
        self.setup_ai_connections().await?;
        
        // Register sidebar during load
        context.ui_registry.register_sidebar_panel(
            self.id(),
            SidebarPanel::new("ai_analysis", "AI Analysis", AnalysisIcon)
        ).await?;
        
        Ok(())
    }
}
```

### Block Plugin Integration Pattern
```rust
// Future block plugins would implement:
impl Plugin for CustomBlockPlugin {
    fn capabilities(&self) -> Vec<PluginCapability> {
        vec![
            // Core block capabilities - these are essential to the system
            PluginCapability::BlockRenderer { block_type: "custom_chart".to_string() },
            PluginCapability::BlockEditor { block_type: "custom_chart".to_string() },
            // Event capabilities for communication
            PluginCapability::EventListener { 
                event_types: vec!["block.custom_chart.render".to_string()] 
            },
        ]
    }
    
    async fn load(&self, context: &PluginContext) -> Result<(), PluginError> {
        // Register context menu during load
        context.ui_registry.register_context_menu(
            self.id(),
            ContextMenu::new("chart_options", vec![
                MenuItem::new("edit_chart", "Edit Chart"),
                MenuItem::new("export_chart", "Export Chart"),
            ])
        ).await?;
        
        // Register resource handlers during load
        context.resource_registry.register_importer(
            self.id(),
            vec!["application/json".to_string(), "text/csv".to_string()],
            self.create_chart_importer()
        ).await?;
        
        Ok(())
    }
    
    // Runtime loading support
    async fn reload(&self, context: &PluginContext) -> Result<(), PluginError> {
        // Unload automatically cleans up registrations by plugin_id
        self.unload().await?;
        self.load(context).await
    }
}

// Plugin can be loaded at runtime:
// capability_registry.discover_plugins(&[plugin_dir]).await?;
// capability_registry.load_plugin(&plugin_path).await?;
```

## Risk Mitigation

### Over-Engineering Risk
- **Mitigation:** Focus only on interfaces and patterns, not implementations
- **Validation:** Ensure all new code is used by existing features
- **Review:** Regular assessment against YAGNI principle

### Performance Impact Risk
- **Mitigation:** Use zero-cost abstractions where possible
- **Validation:** Benchmark database service performance before/after
- **Review:** Profile application startup time

### Complexity Risk
- **Mitigation:** Comprehensive documentation and clear examples
- **Validation:** Code review focusing on clarity and maintainability
- **Review:** Ensure junior developers can understand the patterns

## Acceptance Testing

### Architecture Validation Tests
1. **Module Interface Test:** Verify module trait methods compile and provide expected contracts
2. **Plugin Capability Test:** Confirm plugin minimal capability system supports flexible declarations
3. **Capability Registry Test:** Validate capability querying and plugin discovery works correctly
4. **Runtime Loading Test:** Verify plugins can be loaded, unloaded, and reloaded at runtime
5. **Event Bus Test:** Validate event trait definitions support future event scenarios
6. **Configuration Test:** Verify configuration system handles multi-module scenarios and capability mappings

### Integration Tests
1. **Service Locator Test:** Verify database service registration and retrieval
2. **Capability Registry Test:** Confirm plugin capability registration and querying
3. **Plugin Discovery Test:** Verify plugin discovery from filesystem directories
4. **Runtime Loading Test:** Test plugin loading/unloading without application restart
5. **Context Test:** Confirm application context initializes correctly with all registries
6. **Configuration Loading Test:** Validate configuration loads with module settings and capability config
7. **Startup Test:** Ensure application starts successfully with new architecture

### Documentation Tests
1. **Completeness Test:** Verify all architectural components are documented including minimal capability system
2. **Example Test:** Confirm code examples compile and run, especially capability declarations
3. **Runtime Loading Test:** Validate plugin loading workflow examples are accurate
4. **Extension Point Test:** Validate minimal capability-based extension examples are accurate
5. **Decision Documentation Test:** Ensure rationale for minimal capability approach is clear and complete

---

**Estimated Total Time:** 12-17 hours  
**Dependencies:** Completion of US-001.1, US-001.2, US-001.3  
**Next Phase:** US-003 (Phase 3) - Actual event bus and module registry implementation

This plan establishes the architectural foundation for future extensibility using a **capability-based plugin system** with **registration-based integration** and **runtime loading support**. The approach focuses on core capabilities the framework needs to know about (blocks, events, and system capabilities like audio recording) while allowing plugins to register their UI and resource integrations during their load/unload lifecycle. This provides maximum flexibility while keeping the framework focused on its core responsibilities. Note that actual audio recording implementation is out of scope for Phase 1 - only the infrastructure and capability definitions are being established.
